<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MLP server</title>

  <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/main.min.css" rel="stylesheet" />
  <style>
    .time-toolbar { display:flex; gap:6px; flex-wrap:wrap; }
    .time-toolbar .tiny {
    padding: 4px 8px; font-size:12px; border-radius:8px;
    background: var(--panel); color: var(--text);
    border: 1px solid rgba(255,255,255,0.14); cursor:pointer;
    }
    .time-toolbar .tiny:hover { border-color: var(--brand); }
    .modal .field.two { 
        grid-template-columns: 1fr 1fr; 
    }
    .modal .field.two > div { 
        display: grid; 
        gap: 6px; 
    }
    :root {
      --bg: #0b1020;
      --panel: #121933;
      --text: #e6e9f5;
      --muted: #9aa3b2;
      --brand: #7c91ff;
      --brand-weak: rgba(124,145,255,.18);
      --accent: #222a54;
      --ok: #22c55e;
      --busy: #f97316;
      --danger: #ef4444;
        --dow-bg: rgba(124,145,255,.14);
        --dow-text: #e6e9f5;
        --dow-border: rgba(124,145,255,.28);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 20% -10%, #18224a 0%, #0b1020 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji';
      -webkit-font-smoothing: antialiased;
    }
    header {
      display: flex; gap: 12px; align-items: center; justify-content: space-between;
      padding: 14px 18px; position: sticky; top: 0; z-index: 50;
      background: linear-gradient(180deg, rgba(10,13,25,0.9), rgba(10,13,25,0.6));
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .title { font-weight: 700; letter-spacing: .2px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    button, .btn {
      appearance: none; border: 1px solid rgba(255,255,255,0.14);
      background: var(--panel); color: var(--text);
      padding: 8px 10px; border-radius: 10px; font-size: 14px; cursor: pointer;
    }
    .btn.primary { background: var(--brand); border-color: var(--brand); color: #0b1020; font-weight: 700; }
    .btn.ghost { background: transparent; }
    .segmented { display: inline-flex; border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.14); }
    .segmented button { background: transparent; border: 0; padding: 8px 12px; color: var(--text); }
    .segmented button.active { background: var(--brand); color: #0b1020; font-weight: 700; }

    main { display: grid; grid-template-columns: 300px 1fr; gap: 12px; padding: 16px; }

    aside {
      background: rgba(18,25,51,0.7); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 14px; padding: 12px; height: fit-content;
    }
    .aside-title { font-size: 13px; color: var(--muted); margin-bottom: 8px; }
    .server-list { display: flex; flex-direction: column; gap: 8px; }
    .server-btn { display: flex; align-items: center; justify-content: space-between; gap: 6px; width: 100%; }
    .server-btn.active { outline: 2px solid var(--brand); background: var(--accent); }
    .server-row { display: grid; grid-template-columns: 1fr; gap: 4px; align-items: center; }
    .server-meta { font-size: 12px; color: var(--muted); display: flex; gap: 6px; }

    #calendarWrap { background: rgba(18,25,51,0.7); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 8px; }

    #statusPanel { margin-top: 12px; display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 12px; }
    .status-card { background: rgba(18,25,51,0.9); border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 12px; display: grid; gap: 8px; }
    .status-name { font-weight: 800; letter-spacing:.2px; }
    .gpu-badge { display:inline-flex; gap:6px; align-items:center; font-size:12px; color: var(--muted); }
    .bar { height: 8px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; }
    .bar > span { display:block; height:100%; background: var(--brand); }
    .status-subgrid { display:grid; gap:6px; }
    .chip { display:inline-flex; padding: 2px 6px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.14); font-size: 12px; }
    .muted { color: var(--muted); }
    .status-free { color: var(--ok); }
    .status-busy { color: var(--busy); }

    .fc .fc-toolbar-title { font-size: 16px; font-weight: 700; color: var(--text); }
    .fc .fc-button { background: var(--panel); border: 1px solid rgba(255,255,255,0.12); color: var(--text); border-radius: 10px; padding: 6px 10px; }
    .fc .fc-button-primary { background: var(--brand); border-color: var(--brand); color: #0b1020; }
    .fc-theme-standard td, .fc-theme-standard th, .fc-theme-standard .fc-scrollgrid { border-color: rgba(255,255,255,0.08); }
    .fc .fc-timegrid-slot { height: 20px; }

    .fc .fc-daygrid-day.fc-day-today, .fc .fc-timegrid-col.fc-day-today { background: var(--brand-weak); }
    .fc .fc-highlight { background: rgba(124,145,255,.25); }

    .fc .fc-col-header-cell { background: #ffffff; }
    .fc .fc-col-header-cell-cushion { color: #000000 !important; font-weight: 600; }
    .fc .fc-col-header .fc-day-sat,
    .fc .fc-col-header .fc-day-sun{
    background: rgba(239,68,68,.08);
    }
    .fc-resv { display: flex; flex-direction: column; gap: 2px; font-size: 12px; line-height: 1.2; padding: 2px; color:#ffffff; }
    .fc-resv .line1 { font-weight: 700; filter: drop-shadow(0 1px 0 rgba(0,0,0,0.25)); }
    .fc-resv .line2 { opacity: 0.95; }

    footer { color: var(--muted); font-size: 12px; text-align: center; padding: 16px; }

    .modal-wrap { position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,0.45); z-index: 60; }
    .modal { width: min(520px, 92vw); background: #0e1430; border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .modal h3 { margin: 0 0 8px; font-size: 16px; }
    .modal .desc { font-size: 12px; color: var(--muted); margin-bottom: 10px; }
    .modal .field { display: grid; gap: 6px; margin: 10px 0; }
    .modal input, .modal select { background: var(--panel); border: 1px solid rgba(255,255,255,0.14); color: var(--text); border-radius: 10px; padding: 8px 10px; font-size: 14px; }
    .modal .row { justify-content: flex-end; }
    .modal .note { font-size: 12px; color: var(--muted); }
    .modal .error { color: var(--danger); font-size: 12px; min-height: 16px; }

    @media (max-width: 900px) { main { grid-template-columns: 1fr; } aside { order: 2; } }
  </style>
</head>

<body>
  <header>
    <div class="row"><span class="title">🗓️ 연구실 서버 예약</span></div>
    <div class="row">
      <span style="opacity:.8">사용자:</span>
      <div class="segmented" id="personaGroup">
        <button data-id="송호윤">송호윤</button>
        <button data-id="원인호">원인호</button>
        <button data-id="김민준">김민준</button>
        <button data-id="임현석">임현석</button>
        <button data-id="최창수">최창수</button>
        <button data-id="송승우">송승우</button>
        <button data-id="유한결">유한결</button>
        <button data-id="육정훈">육정훈</button>
        <button data-id="조민경">조민경</button>
        <button data-id="송서현">송서현</button>
        <button data-id="김현규">김현규</button>
      </div>
    </div>
  </header>

  <main>
    <aside>
      <div class="aside-title">서버 리스트</div>
      <div id="serverList" class="server-list"></div>
    </aside>

    <div>
      <div id="calendarWrap"><div id="calendar"></div></div>
      <div id="statusPanel"></div>
    </div>
  </main>

  <div id="createModal" class="modal-wrap" role="dialog" aria-modal="true">
    <div class="modal">
      <h3>새 예약</h3>
      <div class="desc" id="cmServer"></div>
      <div class="field">
        <label for="cmTitle">제목 (선택)</label>
        <input id="cmTitle" type="text" placeholder="Task" />
      </div>
    <div class="field two">
    <div>
        <label for="cmStart">시작</label>
        <input id="cmStart" type="datetime-local" step="900" />
    </div>
    <div>
        <label for="cmEnd">종료</label>
        <input id="cmEnd" type="datetime-local" step="900" />
    </div>
    </div>
      <div class="field">
        <label for="cmGpu">GPU 사용 개수</label>
        <input id="cmGpu" type="number" min="1" step="1" value="1" />
        <div class="note" id="cmAvail"></div>
      </div>
      <div class="error" id="cmError"></div>
      <div class="row">
        <button id="cmCancel" type="button" class="btn ghost">취소</button>
        <button id="cmSave"   type="button" class="btn primary">저장</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/locales/ko.global.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  (function () {
    // ✨ 변경: 변수명 충돌을 피하기 위해 supabaseClient로 변경
    const SUPABASE_URL = 'https://bqfnrrygflnkseoeilqt.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJxZm5ycnlnZmxua3Nlb2VpbHF0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY5MTUyNzIsImV4cCI6MjA3MjQ5MTI3Mn0.mOvH05HXZGLN4mNr6pwCSnxmq7OZseOU5lA7fZcs33k';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
      
    const ADMINS = new Set(['김민준']);
    const PERSONAS = [
        { id: '김민준', name: '김민준', color: '#4338ca' },
        { id: '원인호', name: '원인호', color: '#1d4ed8' },
        { id: '송호윤', name: '송호윤', color: '#047857' },
        { id: '임현석', name: '임현석', color: '#c2410c' },
        { id: '유한결', name: '유한결', color: '#b45309' },
        { id: '최창수', name: '최창수', color: '#4d7c0f' },
        { id: '송승우', name: '송승우', color: '#15803d' },
        { id: '육정훈', name: '육정훈', color: '#0f766e' },
        { id: '조민경', name: '조민경', color: '#0e7490' },
        { id: '김현규', name: '김현규', color: '#0369a1' },
        { id: '송서현', name: '송서현', color: '#6d28d9' },
    ];

    const SERVERS = [
        { id: '과기대 H100', name: '과기대 H100', gpuType: 'H100 80GB', gpuCount: 8 },
        { id: 'KAIST H200', name: 'KAIST H200', gpuType: 'H200 141GB', gpuCount: 2 },
        { id: 'AICA H100', name: 'AICA H100', gpuType: 'H100 80GB', gpuCount: 16 },
        { id: '테디썸 H200', name: '테디썸 H200', gpuType: 'H200 141GB', gpuCount: 8 },
        { id: 'WBL H200', name: 'WBL H200', gpuType: 'H200 141GB', gpuCount: 4 },
        { id: '테디썸 203', name: '테디썸 203', gpuType: 'A100 80GB', gpuCount: 4 },
        { id: '테디썸 205', name: '테디썸 205', gpuType: 'A100 80GB', gpuCount: 4 },
        { id: '과기대 A6000', name: '과기대 A6000', gpuType: 'A6000 40GB', gpuCount: 3 },
    ];

    const LS_KEY_PERSONA  = 'lab-current-persona';
    const LS_KEY_SERVER   = 'lab-current-server';

    let currentPersona = null;
    let currentServerId = null;
    let calendar = null;

    const MS_PER_DAY = 86400000;
    const sameId = (a,b)=> String(a||'').trim().toLowerCase() === String(b||'').trim().toLowerCase();
    const isAdmin = ()=> !!(currentPersona && ADMINS.has(currentPersona.id));
    const toMs = (v)=> typeof v === 'number' ? v : new Date(v).getTime();
    const ymdUTC = (d)=> Date.UTC(d.getFullYear(), d.getMonth(), d.getDate());

    function startOfDay(d){ const x = new Date(d); x.setHours(0,0,0,0); return x; }
    function endOfDay(d){ const x = new Date(d); x.setHours(23,59,59,999); return x; }

    function toOffsetISOStringLocal(date){
      const d = new Date(date);
      const pad = (n)=> String(n).padStart(2,'0');
      const yyyy = d.getFullYear();
      const MM = pad(d.getMonth()+1);
      const DD = pad(d.getDate());
      const hh = pad(d.getHours());
      const mm = pad(d.getMinutes());
      const ss = pad(d.getSeconds());
      const tzMin = -d.getTimezoneOffset();
      const sign = tzMin >= 0 ? '+' : '-';
      const absm = Math.abs(tzMin);
      const tzh = pad(Math.floor(absm/60));
      const tzm = pad(absm%60);
      return `${yyyy}-${MM}-${DD}T${hh}:${mm}:${ss}${sign}${tzh}:${tzm}`;
    }
    
    async function loadEvents() {
        const { data, error } = await supabaseClient // ✨ 변경
            .from('reservations')
            .select('*');

        if (error) {
            console.error('데이터 로딩 실패:', error);
            return [];
        }

        const events = data.map(e => ({
            ...e,
            start: e.start_time,
            end: e.end_time,
            gpuUsed: e.gpu_used,
            ownerId: e.owner_id,
            serverId: e.server_id,
        }));

        return ensureMsFields(events);
    }

    function getServerById(id){ return SERVERS.find(s => sameId(s.id, id)) || null; }
    
    function ensureMsFields(evts){
      for (const e of evts) {
          if (typeof e.startMs !== 'number') { e.startMs = toMs(e.start); }
          if (typeof e.endMs   !== 'number') { e.endMs   = toMs(e.end); }
      }
      return evts;
    }

    function setPersona(id) {
      currentPersona = PERSONAS.find(p => p.id === id) || PERSONAS[0];
      localStorage.setItem(LS_KEY_PERSONA, currentPersona.id);
      document.querySelectorAll('#personaGroup button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.id === currentPersona.id);
      });
      calendar?.refetchEvents();
      renderStatusPanel();
    }
    function setServer(id) {
      currentServerId = id;
      localStorage.setItem(LS_KEY_SERVER, id || '');
      document.querySelectorAll('.server-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.id === id);
      });
      calendar?.refetchEvents();
    }

    const overlapMs = (aStartMs, aEndMs, bStartMs, bEndMs)=> (aStartMs < bEndMs) && (aEndMs > bStartMs);

    function fmt(dt) {
      const d = new Date(dt);
      const mm = (d.getMonth()+1).toString().padStart(2,'0');
      const dd = d.getDate().toString().padStart(2,'0');
      const hh = d.getHours().toString().padStart(2,'0');
      const mi = d.getMinutes().toString().padStart(2,'0');
      return `${mm}/${dd} ${hh}:${mi}`;
    }
    const fmtRange = (s, e)=> `${fmt(s)}~${fmt(e)}`;
      function toLocalInputValue(d){
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
      }
      function fromLocalInputValue(v){
      if(!v) return null;
      const [date, time='00:00'] = v.split('T');
      const [y,m,d] = date.split('-').map(Number);
      const [hh,mm] = time.split(':').map(Number);
      return new Date(y, (m||1)-1, d||1, hh||0, mm||0, 0, 0);
      }

    function buildPersonaButtons() {
      const group = document.getElementById('personaGroup');
      PERSONAS.forEach(p => {
        const btn = group.querySelector(`button[data-id="${p.id}"]`);
        if (btn) {
          btn.style.borderRight = '1px solid rgba(0,0,0,0.0)';
          btn.addEventListener('click', () => setPersona(p.id));
        }
      });
      const saved = localStorage.getItem(LS_KEY_PERSONA);
      setPersona(saved && PERSONAS.some(p=>p.id===saved) ? saved : '김민준');
    }

    function buildServerList() {
      const wrap = document.getElementById('serverList');
      wrap.innerHTML = '';
      SERVERS.forEach(s => {
        const row = document.createElement('div');
        row.className = 'server-row';

        const selBtn = document.createElement('button');
        selBtn.className = 'btn server-btn';
        selBtn.dataset.id = s.id;
        selBtn.innerHTML = `<span>${s.name}</span><span class="muted" style="font-size:12px;">선택</span>`;
        selBtn.addEventListener('click', () => setServer(s.id));

        const meta = document.createElement('div');
        meta.className = 'server-meta';
        meta.innerHTML = `<span class="chip">GPU: ${s.gpuType}</span><span class="chip">${s.gpuCount}개</span>`;

        row.appendChild(selBtn);
        row.appendChild(meta);
        wrap.appendChild(row);
      });

      const saved = localStorage.getItem(LS_KEY_SERVER);
      const current = (saved && SERVERS.some(s=>s.id===saved)) ? saved : (SERVERS[0]?.id || null);
      setServer(current);
    }

    function mapToFcEvent(r) {
      const owner = PERSONAS.find(p => p.id === r.ownerId) || { name: r.ownerId, color: '#1f2937' };
      const server = getServerById(r.serverId);
      const gpuTxt = r.gpuUsed ? ` · ${r.gpuUsed}GPU` : '';
      const startMs = (typeof r.startMs === 'number') ? r.startMs : toMs(r.start);
      const endMs   = (typeof r.endMs   === 'number') ? r.endMs   : toMs(r.end);
      const startISO = toOffsetISOStringLocal(new Date(startMs));
      const endISO   = toOffsetISOStringLocal(new Date(endMs));
      return {
        id: r.id,
        title: r.title || '',
        start: startISO,
        end: endISO,
        backgroundColor: owner.color,
        borderColor: owner.color,
        textColor: '#ffffff',
        extendedProps: {
          ownerId: r.ownerId,
          ownerName: owner.name,
          serverId: r.serverId,
          serverName: (server?.name || r.serverId) + gpuTxt,
          gpuUsed: r.gpuUsed ?? 1,
          startMs,
          endMs,
        }
      };
    }

    function renderEventContent(arg) {
      const { ownerName, serverName } = arg.event.extendedProps || {};
      const title = arg.event.title ? ` — ${arg.event.title}` : '';
      const range = `(${fmtRange(arg.event.start, arg.event.end)})`;
      const el = document.createElement('div');
      el.className = 'fc-resv';
      el.style.color = '#ffffff';
      el.innerHTML = `<div class="line1">[${serverName}]${title}</div><div class="line2">${ownerName || ''} ${range}</div>`;
      return { domNodes: [el] };
    }

    async function renderStatusPanel() {
      const panel = document.getElementById('statusPanel');
      const nowMs = Date.now();
      const events = await loadEvents();
      panel.innerHTML = '';
      SERVERS.forEach(s => {
        const serverEventsNow = events.filter(e =>
          sameId(e.serverId, s.id) &&
          toMs(e.start) <= nowMs && nowMs < toMs(e.end)
        );
        const used = serverEventsNow.reduce((sum,e)=> sum + (Number(e.gpuUsed??1)||1), 0);
        const free = Math.max(0, s.gpuCount - used);

        const card = document.createElement('div');
        card.className = 'status-card';
        card.innerHTML = `
          <div class="status-name">${s.name}</div>
          <div class="gpu-badge">GPU: <span class="chip">${s.gpuType}</span> <span class="chip">총 ${s.gpuCount}개</span></div>
          <div class="bar"><span style="width:${Math.min(100, Math.max(0, (used/s.gpuCount)*100))}%;"></span></div>
          <div class="status-subgrid">
            <div><strong>${free}</strong>/<strong>${s.gpuCount}</strong> GPUs available</div>
            ${serverEventsNow.length===0 ? `<div class="status-free">현재 모두 사용 가능</div>` : serverEventsNow.map(e=>{
              const owner = PERSONAS.find(p=>p.id===e.ownerId)?.name || e.ownerId;
              return `<div class="chip">${owner} · ${e.gpuUsed??1}GPU · until ${fmt(e.end)}</div>`;
            }).join('')}
          </div>
        `;
        panel.appendChild(card);
      });
    }

      const createModal = {
      el: null, saveBtn: null, cancelBtn: null,
      titleEl: null, gpuEl: null, availEl: null, descEl: null, errEl: null,
      startEl: null, endEl: null,
      ctx: null,

      async open(ctx){
        this.ctx = ctx;
        if(!this.el){
        this.el        = document.getElementById('createModal');
        this.saveBtn   = document.getElementById('cmSave');
        this.cancelBtn = document.getElementById('cmCancel');
        this.titleEl   = document.getElementById('cmTitle');
        this.gpuEl     = document.getElementById('cmGpu');
        this.availEl   = document.getElementById('cmAvail');
        this.descEl    = document.getElementById('cmServer');
        this.errEl     = document.getElementById('cmError');
        this.startEl   = document.getElementById('cmStart');
        this.endEl     = document.getElementById('cmEnd');

        this.cancelBtn.addEventListener('click', ()=> this.close());
        this.el.addEventListener('click', (e)=>{ if(e.target===this.el) this.close(); });
        this.saveBtn.addEventListener('click', ()=> this.save());

        const onChange = ()=> this.recalc();
        this.startEl.addEventListener('input', onChange);
        this.endEl.addEventListener('input', onChange);
        this.gpuEl.addEventListener('input', onChange);
        }

        this.startEl.value = toLocalInputValue(ctx.start);
        this.endEl.value   = toLocalInputValue(ctx.end);
        this.titleEl.value = '';
        this.gpuEl.value   = '1';
        this.errEl.textContent = '';
        this.el.style.display = 'grid';

        await this.recalc();
        setTimeout(()=> this.titleEl.focus(), 0);
      },

      async recalc(){
        if(!this.ctx) return;
        const start = fromLocalInputValue(this.startEl.value);
        const end   = fromLocalInputValue(this.endEl.value);

        if(!(start && end) || !(start < end)){
          this.errEl.textContent = '종료 시각은 시작 시각보다 늦어야 합니다.';
          this.availEl.textContent = '';
          this.saveBtn.disabled = true;
          return;
        }
        
        const events = await loadEvents();
        const usedInRange = events.reduce((sum,e)=>{
          if(!sameId(e.serverId, this.ctx.server.id)) return sum;
          if(!overlapMs(start.getTime(), end.getTime(), toMs(e.start), toMs(e.end))) return sum;
          return sum + (Number(e.gpuUsed??1)||1);
        },0);

        const cap = Number(this.ctx.server.gpuCount||0);
        const available = Math.max(0, cap - usedInRange);

        this.gpuEl.min = '1';
        this.gpuEl.max = String(Math.max(available,1));
        const cur = Math.max(1, Math.min(Number(this.gpuEl.value||'1'), Math.max(available,1)));
        this.gpuEl.value = String(cur);

        this.descEl.textContent = `서버: ${this.ctx.server.name} (${this.ctx.server.gpuType}, 총 ${cap}GPU) · 기간: ${fmtRange(start, end)}`;
        this.availEl.textContent = `이 시간대 사용 가능: ${available} / ${cap} GPU`;
        this.errEl.textContent = available>0 ? '' : '해당 시간대에 사용 가능한 GPU가 없습니다.';
        this.saveBtn.disabled = available<=0;
      },

      close(){
        this.el.style.display = 'none';
        this.errEl.textContent = '';
        this.titleEl.value = '';
        this.gpuEl.value = '1';
        this.ctx = null;
      },
      
      async save(){
        if(!this.ctx) return;
        const title = this.titleEl.value.trim();
        const gpuUsed = parseInt(this.gpuEl.value || '1', 10);
        const start = fromLocalInputValue(this.startEl.value) || this.ctx.start;
        const end   = fromLocalInputValue(this.endEl.value)   || this.ctx.end;
        if(!isFinite(gpuUsed) || gpuUsed<1){ this.errEl.textContent='GPU 개수는 1 이상이어야 합니다.'; return; }
        if(!(start < end)){ this.errEl.textContent='종료 시각은 시작 시각보다 늦어야 합니다.'; return; }

        const cand = {
          serverId: this.ctx.server.id,
          start: toOffsetISOStringLocal(start),
          end: toOffsetISOStringLocal(end),
          startMs: start.getTime(),
          endMs: end.getTime(),
          gpuUsed
        };
        if(! (await validateCapacity(cand)) ) {
          this.errEl.textContent = 'GPU 용량을 초과하여 예약할 수 없어요.'; return; 
        }

        const newRowData = {
          owner_id: currentPersona.id,
          title: title || null,
          server_id: cand.serverId,
          start_time: cand.start,
          end_time: cand.end,
          gpu_used: cand.gpuUsed
        };

        const { error } = await supabaseClient.from('reservations').insert(newRowData); // ✨ 변경

        if (error) {
          this.errEl.textContent = '예약 저장에 실패했습니다: ' + error.message;
          return;
        }

        calendar.refetchEvents();
        renderStatusPanel();
        this.close();
      }
      };

    async function validateCapacity(candidate, exceptId){
      const server = getServerById(candidate.serverId); if(!server) return false;
      const cap = Number(server.gpuCount||0);
      const cStart = candidate.startMs ?? toMs(candidate.start);
      const cEnd   = candidate.endMs   ?? toMs(candidate.end);
      
      const events = await loadEvents();
      const used = events.reduce((sum,e)=>{
        if(e.id===exceptId) return sum;
        if(!sameId(e.serverId, candidate.serverId)) return sum;
        if(!overlapMs(cStart, cEnd, toMs(e.start), toMs(e.end))) return sum;
        const u = Number(e.gpuUsed ?? 1);
        return sum + (isFinite(u) && u>0 ? u : 1);
      }, 0);
      const need = Number(candidate.gpuUsed ?? 1);
      return (used + need) <= cap;
    }

    async function initCalendar() {
      const calendarEl = document.getElementById('calendar');
      calendar = new FullCalendar.Calendar(calendarEl, {
        locale: 'ko',
        timeZone: 'Asia/Seoul',
        initialView: 'dayGridMonth',
        height: 'auto',
        selectable: true,
        selectMirror: true,
        editable: true,
        dayMaxEvents: true,
        nowIndicator: true,
        headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,timeGridWeek,timeGridDay' },
        eventTimeFormat: { hour: '2-digit', minute: '2-digit', hour12: false },
        eventContent: renderEventContent,
        
        events: async (fetchInfo, successCallback, failureCallback) => {
          try {
              const data = await loadEvents();
              successCallback(data.map(mapToFcEvent));
          } catch (error) {
              failureCallback(error);
          }
        },

        dateClick: (info) => {
          if (!currentServerId) { alert('좌측에서 서버를 먼저 선택하세요.'); return; }
          if (!currentPersona) { alert('상단에서 사용자를 선택하세요.'); return; }
          const server = getServerById(currentServerId);
          if(!server){ alert('서버 정보를 찾을 수 없습니다.'); return; }

          let selStart, selEnd;
          if (info.view?.type?.startsWith('dayGrid')) {
            selStart = startOfDay(info.date);
            selEnd   = endOfDay(info.date);
          } else {
            selStart = info.date;
            selEnd   = new Date(info.date.getTime() + 60*60*1000);
          }
          createModal.open({ server, start: selStart, end: selEnd });
        },
        select: (info) => {
          if (!currentServerId) { alert('좌측에서 서버를 먼저 선택하세요.'); calendar.unselect(); return; }
          if (!currentPersona) { alert('상단에서 사용자를 선택하세요.'); calendar.unselect(); return; }
          const server = getServerById(currentServerId);
          if(!server){ alert('서버 정보를 찾을 수 없습니다.'); calendar.unselect(); return; }

          let selStart, selEnd;
          if (info.view?.type?.startsWith('dayGrid')) {
            selStart = startOfDay(info.start);
            
            // ✨ 여기가 수정된 부분입니다.
            // info.end는 선택한 마지막 날의 다음 날 0시이므로, 하루를 빼서 마지막 날을 정확히 계산합니다.
            const inclusiveEnd = new Date(info.end);
            inclusiveEnd.setDate(inclusiveEnd.getDate() - 1);
            selEnd = endOfDay(inclusiveEnd);

          } else {
            selStart = info.start;
            selEnd   = info.end;
          }

          createModal.open({ server, start: selStart, end: selEnd });
          calendar.unselect();
        },
        eventDrop: async (info) => {
          const ownerId = info.event.extendedProps?.ownerId;
          if (!currentPersona || (!isAdmin() && ownerId !== currentPersona.id)) { alert('본인 예약만 이동할 수 있어요.'); info.revert(); return; }

          const oldStartMs = info.event.extendedProps?.startMs;
          const oldEndMs   = info.event.extendedProps?.endMs;
          let newStartMs, newEndMs;

          if (info.view?.type?.startsWith('dayGrid')) {
            const oldStart = new Date(oldStartMs);
            const newStart = info.event.start;
            const dayDelta = Math.round((ymdUTC(newStart) - ymdUTC(oldStart)) / MS_PER_DAY);
            newStartMs = oldStartMs + dayDelta * MS_PER_DAY;
            newEndMs   = oldEndMs   + dayDelta * MS_PER_DAY;
          } else {
            newStartMs = info.event.start.getTime();
            newEndMs   = info.event.end.getTime();
          }

          const updated = {
            start: toOffsetISOStringLocal(new Date(newStartMs)),
            end:   toOffsetISOStringLocal(new Date(newEndMs)),
            startMs: newStartMs,
            endMs:   newEndMs,
            gpuUsed: info.event.extendedProps?.gpuUsed ?? 1
          };

          if (! (await validateCapacity({ serverId: info.event.extendedProps.serverId, ...updated }, info.event.id)) ) {
            alert('GPU 용량을 초과하여 이동할 수 없어요.');
            info.revert();
            return;
          }
          
          const { error } = await supabaseClient
            .from('reservations')
            .update({ start_time: updated.start, end_time: updated.end })
            .eq('id', info.event.id);

          if (error) {
            alert('업데이트에 실패했습니다: ' + error.message);
            info.revert();
            return;
          }
          calendar.refetchEvents();
          renderStatusPanel();
        },
        eventResize: async (info) => {
          const ownerId = info.event.extendedProps?.ownerId;
          if (!currentPersona || (!isAdmin() && ownerId !== currentPersona.id)) { alert('본인 예약만 수정할 수 있어요.'); info.revert(); return; }

          let newStartMs = info.event.start.getTime();
          let newEndMs   = info.event.end.getTime();

          const updated = {
            start: toOffsetISOStringLocal(new Date(newStartMs)),
            end:   toOffsetISOStringLocal(new Date(newEndMs)),
            startMs: newStartMs,
            endMs:   newEndMs,
            gpuUsed: info.event.extendedProps?.gpuUsed ?? 1
          };

          if (! (await validateCapacity({ serverId: info.event.extendedProps.serverId, ...updated }, info.event.id)) ) {
            alert('GPU 용량을 초과하여 수정할 수 없어요.');
            info.revert();
            return;
          }
          
          const { error } = await supabaseClient
            .from('reservations')
            .update({ start_time: updated.start, end_time: updated.end })
            .eq('id', info.event.id);

          if (error) {
            alert('업데이트에 실패했습니다: ' + error.message);
            info.revert();
            return;
          }
          calendar.refetchEvents();
          renderStatusPanel();
        },
        eventClick: async (info) => {
          const ownerId = info.event.extendedProps?.ownerId;
          const serverName = info.event.extendedProps?.serverName;
          const canDelete = currentPersona && (isAdmin() || ownerId === currentPersona.id);
          if (!canDelete) { alert('내 예약만 삭제할 수 있어요.'); return; }
          
          if (confirm(`[${serverName}] 예약을 삭제할까요?`)) {
            const { error } = await supabaseClient
              .from('reservations')
              .delete()
              .eq('id', info.event.id);

            if (error) {
              alert('삭제에 실패했습니다: ' + error.message);
              return;
            }
            calendar.refetchEvents();
            renderStatusPanel();
          }
        }
      });
      calendar.render();
    }

    buildPersonaButtons();
    buildServerList();
    initCalendar();
    renderStatusPanel();
    setInterval(renderStatusPanel, 15000);
  })();
  </script>
</body>
</html>
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MLP server</title>

  <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/main.min.css" rel="stylesheet" />
  <style>
    .time-toolbar { display:flex; gap:6px; flex-wrap:wrap; }
    .time-toolbar .tiny {
      padding: 4px 8px; font-size:12px; border-radius:8px;
      background: var(--panel); color: var(--text);
      border: 1px solid rgba(255,255,255,0.14); cursor:pointer;
    }
    .time-toolbar .tiny:hover { border-color: var(--brand); }
    .modal .field.two { grid-template-columns: 1fr 1fr; }
    .modal .field.two > div { display: grid; gap: 6px; }
    :root {
      --bg: #0b1020;
      --panel: #121933;
      --text: #e6e9f5;
      --muted: #9aa3b2;
      --brand: #7c91ff;
      --brand-weak: rgba(124,145,255,.18);
      --accent: #222a54;
      --ok: #22c55e;
      --busy: #f97316;
      --danger: #ef4444;
      --dow-bg: rgba(124,145,255,.14);
      --dow-text: #e6e9f5;
      --dow-border: rgba(124,145,255,.28);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 20% -10%, #18224a 0%, #0b1020 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji';
      -webkit-font-smoothing: antialiased;
    }
    header {
      display: flex; gap: 12px; align-items: center; justify-content: space-between;
      padding: 14px 18px; position: sticky; top: 0; z-index: 50;
      background: linear-gradient(180deg, rgba(10,13,25,0.9), rgba(10,13,25,0.6));
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .title { font-weight: 700; letter-spacing: .2px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    button, .btn {
      appearance: none; border: 1px solid rgba(255,255,255,0.14);
      background: var(--panel); color: var(--text);
      padding: 8px 10px; border-radius: 10px; font-size: 14px; cursor: pointer;
    }
    .btn.primary { background: var(--brand); border-color: var(--brand); color: #0b1020; font-weight: 700; }
    .btn.ghost { background: transparent; }
    .segmented { display: inline-flex; border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.14); }
    .segmented button { background: transparent; border: 0; padding: 8px 12px; color: var(--text); }
    .segmented button.active { background: var(--brand); color: #0b1020; font-weight: 700; }

    main { display: grid; grid-template-columns: 300px 1fr; gap: 12px; padding: 16px; }

    aside {
      background: rgba(18,25,51,0.7); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 14px; padding: 12px; height: fit-content;
    }
    .aside-title { font-size: 13px; color: var(--muted); margin-bottom: 8px; }
    .server-list { display: flex; flex-direction: column; gap: 8px; }
    .server-btn { display: flex; align-items: center; justify-content: space-between; gap: 6px; width: 100%; }
    .server-btn.active { outline: 2px solid var(--brand); background: var(--accent); }
    .server-row { display: grid; grid-template-columns: 1fr; gap: 4px; align-items: center; }
    .server-meta { font-size: 12px; color: var(--muted); display: flex; gap: 6px; }

    #calendarWrap { background: rgba(18,25,51,0.7); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 8px; }

    #statusPanel { margin-top: 12px; display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 12px; }
    .status-card { background: rgba(18,25,51,0.9); border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 12px; display: grid; gap: 8px; }
    .status-name { font-weight: 800; letter-spacing:.2px; }
    .gpu-badge { display:inline-flex; gap:6px; align-items:center; font-size:12px; color: var(--muted); }
    .bar { height: 8px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; }
    .bar > span { display:block; height:100%; background: var(--brand); }
    .status-subgrid { display:grid; gap:6px; }
    .chip { display:inline-flex; padding: 2px 6px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.14); font-size: 12px; }
    .muted { color: var(--muted); }
    .status-free { color: var(--ok); }
    .status-busy { color: var(--busy); }

    .fc .fc-toolbar-title { font-size: 16px; font-weight: 700; color: var(--text); }
    .fc .fc-button { background: var(--panel); border: 1px solid rgba(255,255,255,0.12); color: var(--text); border-radius: 10px; padding: 6px 10px; }
    .fc .fc-button-primary { background: var(--brand); border-color: var(--brand); color: #0b1020; }
    .fc-theme-standard td, .fc-theme-standard th, .fc-theme-standard .fc-scrollgrid { border-color: rgba(255,255,255,0.08); }
    .fc .fc-timegrid-slot { height: 20px; }

    .fc .fc-daygrid-day.fc-day-today, .fc .fc-timegrid-col.fc-day-today { background: var(--brand-weak); }
    .fc .fc-highlight { background: rgba(124,145,255,.25); }

    .fc .fc-col-header-cell { background: #ffffff; }
    .fc .fc-col-header-cell-cushion { color: #000000 !important; font-weight: 600; }
    .fc .fc-col-header .fc-day-sat,
    .fc .fc-col-header .fc-day-sun{ background: rgba(239,68,68,.08); }
    .fc-resv { display: flex; flex-direction: column; gap: 2px; font-size: 12px; line-height: 1.2; padding: 2px; color:#ffffff; }
    .fc-resv .line1 { font-weight: 700; filter: drop-shadow(0 1px 0 rgba(0,0,0,0.25)); }
    .fc-resv .line2 { opacity: 0.95; }

    footer { color: var(--muted); font-size: 12px; text-align: center; padding: 16px; }

    .modal-wrap { position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,0.45); z-index: 60; }
    .modal { width: min(600px, 92vw); background: #0e1430; border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .modal h3 { margin: 0 0 8px; font-size: 16px; }
    .modal .desc { font-size: 12px; color: var(--muted); margin-bottom: 10px; }
    .modal .field { display: grid; gap: 6px; margin: 10px 0; }
    .modal input, .modal select { background: var(--panel); border: 1px solid rgba(255,255,255,0.14); color: var(--text); border-radius: 10px; padding: 8px 10px; font-size: 14px; }
    .modal .row { justify-content: flex-end; }
    .modal .note { font-size: 12px; color: var(--muted); }
    .modal .error { color: var(--danger); font-size: 12px; min-height: 16px; }

    /* ▼▼ NEW: Context menu styles */
    .context-menu { position: fixed; background: #0e1430; border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 6px; display: none; z-index: 70; min-width: 150px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .context-menu button { display:block; width:100%; background: transparent; border: 0; padding: 8px 10px; color: var(--text); text-align:left; border-radius: 8px; font-size: 14px; }
    .context-menu button:hover { background: var(--accent); }
    /* ▲▲ NEW */

    @media (max-width: 900px) { main { grid-template-columns: 1fr; } aside { order: 2; } }
  </style>
</head>

<body>
  <header>
    <div class="row"><span class="title">🗓️ 연구실 서버 예약</span></div>
    <div class="row">
      <span style="opacity:.8">사용자:</span>
      <div class="segmented" id="personaGroup">
        <button data-id="송호윤">송호윤</button>
        <button data-id="허찬">허찬</button>
        <button data-id="원인호">원인호</button>
        <button data-id="김민준">김민준</button>
        <button data-id="임현석">임현석</button>
        <button data-id="최창수">최창수</button>
        <button data-id="송승우">송승우</button>
        <button data-id="유한결">유한결</button>
        <button data-id="육정훈">육정훈</button>
        <button data-id="조민경">조민경</button>
        <button data-id="송서현">송서현</button>
        <button data-id="김현규">김현규</button>
        <button data-id="튜터러스랩스 신동재연구원">튜터러스랩스 신동재연구원</button>
      </div>
    </div>
  </header>

  <main>
    <aside>
      <div class="aside-title">서버 리스트</div>
      <div id="serverList" class="server-list"></div>
    </aside>

    <div>
      <div id="calendarWrap"><div id="calendar"></div></div>
      <div id="statusPanel"></div>
    </div>
  </main>

  <div id="createModal" class="modal-wrap" role="dialog" aria-modal="true">
    <div class="modal">
      <h3>새 예약</h3>
      <div class="desc" id="cmServer"></div>
      <div class="field">
        <label for="cmTitle">제목 (선택)</label>
        <input id="cmTitle" type="text" placeholder="Task" />
      </div>
      <div class="field two">
        <div>
          <label for="cmStart">시작</label>
          <input id="cmStart" type="datetime-local" step="60" />
        </div>
        <div>
          <label for="cmEnd">종료</label>
          <input id="cmEnd" type="datetime-local" step="60" />
        </div>
      </div>
      <div class="field">
        <label for="cmGpu">GPU 사용 개수</label>
        <input id="cmGpu" type="number" min="1" step="1" value="1" />
        <div class="note" id="cmAvail"></div>
      </div>
      <div class="error" id="cmError"></div>
      <div class="row">
        <button id="cmCancel" type="button" class="btn ghost">취소</button>
        <button id="cmSave"   type="button" class="btn primary">저장</button>
      </div>
    </div>
  </div>

  <!-- ▼▼ NEW: Edit modal -->
  <div id="editModal" class="modal-wrap" role="dialog" aria-modal="true">
    <div class="modal">
      <h3>예약 수정</h3>
      <div class="desc" id="emServer"></div>
      <div class="field">
        <label for="emTitle">제목 (선택)</label>
        <input id="emTitle" type="text" placeholder="Task" />
      </div>
      <div class="field two">
        <div>
          <label for="emStart">시작</label>
          <input id="emStart" type="datetime-local" step="60" />
        </div>
        <div>
          <label for="emEnd">종료</label>
          <input id="emEnd" type="datetime-local" step="60" />
        </div>
      </div>
      <div class="field">
        <label for="emGpu">GPU 사용 개수</label>
        <input id="emGpu" type="number" min="1" step="1" value="1" />
        <div class="note" id="emAvail"></div>
      </div>
      <div class="error" id="emError"></div>
      <div class="row">
        <button id="emCancel" type="button" class="btn ghost">취소</button>
        <button id="emSave"   type="button" class="btn primary">저장</button>
      </div>
    </div>
  </div>
  <!-- ▲▲ NEW -->

  <!-- ▼▼ NEW: context menu container (populated by JS) -->
  <div id="ctxMenu" class="context-menu" role="menu" aria-hidden="true" style="display:none"></div>
  <!-- ▲▲ NEW -->

  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/locales/ko.global.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  (function () {
    const SUPABASE_URL = 'https://bqfnrrygflnkseoeilqt.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJxZm5ycnlnZmxua3Nlb2VpbHF0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY5MTUyNzIsImV4cCI6MjA3MjQ5MTI3Mn0.mOvH05HXZGLN4mNr6pwCSnxmq7OZseOU5lA7fZcs33k';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    const ADMINS = new Set(['김민준']);
    const PERSONAS = [
      { id: '김민준', name: '김민준', color: '#4338ca' },
      { id: '원인호', name: '원인호', color: '#1d4ed8' },
      { id: '송호윤', name: '송호윤', color: '#047857' },
      { id: '임현석', name: '임현석', color: '#c2410c' },
      { id: '유한결', name: '유한결', color: '#b45309' },
      { id: '최창수', name: '최창수', color: '#4d7c0f' },
      { id: '송승우', name: '송승우', color: '#15803d' },
      { id: '육정훈', name: '육정훈', color: '#0f766e' },
      { id: '조민경', name: '조민경', color: '#0e7490' },
      { id: '김현규', name: '김현규', color: '#0369a1' },
      { id: '송서현', name: '송서현', color: '#6d28d9' },
      { id: '튜터러스랩스 신동재연구원', name: '튜터러스랩스 신동재연구원', color: '#ff0000' },
      { id: '허찬', name: '허찬', color: '#0891b2' },
    ];

    const SERVERS = [
      { id: '과기대 H100', name: '과기대 H100', gpuType: 'H100 80GB', gpuCount: 8 },
      { id: 'KAIST H200', name: 'KAIST H200', gpuType: 'H200 141GB', gpuCount: 2 },
      { id: 'AICA H100', name: 'AICA H100', gpuType: 'H100 80GB', gpuCount: 16 },
      { id: '테디썸 H200', name: '테디썸 H200', gpuType: 'H200 141GB', gpuCount: 8 },
      { id: 'WBL H200', name: 'WBL H200', gpuType: 'H200 141GB', gpuCount: 4 },
      { id: '한밭대 A100', name: '한밭대 A100', gpuType: 'A100 80GB', gpuCount: 4 },
      { id: '테디썸 203', name: '테디썸 203', gpuType: 'A100 80GB', gpuCount: 8 },
      { id: '테디썸 205', name: '테디썸 205', gpuType: 'A100 80GB', gpuCount: 8 },
      { id: '과기대 A6000', name: '과기대 A6000', gpuType: 'A6000 40GB', gpuCount: 3 },
    ];

    const LS_KEY_PERSONA = 'lab-current-persona';
    const LS_KEY_SERVER  = 'lab-current-server';

    let currentPersona = null;
    let currentServerId = null;
    let calendar = null;

    const MS_PER_DAY = 86400000;
    const sameId = (a,b)=> String(a||'').trim().toLowerCase() === String(b||'').trim().toLowerCase();
    const isAdmin = ()=> !!(currentPersona && ADMINS.has(currentPersona.id));
    const toMs = (v)=> typeof v === 'number' ? v : new Date(v).getTime();
    const ymdUTC = (d)=> Date.UTC(d.getFullYear(), d.getMonth(), d.getDate());

    // Helpers
    function startOfDay(d){ const x = new Date(d); x.setHours(0,0,0,0); return x; }
    function endOfDay(d){ const x = new Date(d); x.setHours(23,59,59,999); return x; }
    function addDays(d,n){ const x = new Date(d); x.setDate(x.getDate()+n); return x; }
    function endOfDayForInput(d){ const x = new Date(d); x.setHours(23,59,0,0); return x; } // 23:59 (분 단위)
    function toDateSafe(x){
      if (x instanceof Date) return x;
      if (typeof x === 'string' && x.indexOf('T') === -1 && /^\d{4}-\d{2}-\d{2}\s/.test(x)) {
        return new Date(x.replace(' ','T'));
      }
      return new Date(x);
    }
    function looksAllDaySpan(s,e){
      return s.getHours()===0 && s.getMinutes()===0 && e.getHours()===0 && e.getMinutes()===0 && (((e - s) % MS_PER_DAY) === 0);
    }

    async function loadEvents() {
      const { data, error } = await supabaseClient
        .from('reservations')
        .select('*');

      if (error) {
        console.error('데이터 로딩 실패:', error);
        return [];
      }

      const events = data.map(e => ({
        ...e,
        start: e.start_time,
        end: e.end_time,
        gpuUsed: e.gpu_used,
        ownerId: e.owner_id,
        serverId: e.server_id,
      }));

      return ensureMsFields(events);
    }

    function getServerById(id){ return SERVERS.find(s => sameId(s.id, id)) || null; }

    function ensureMsFields(evts){
      for (const e of evts) {
        if (typeof e.startMs !== 'number') { e.startMs = toMs(e.start); }
        if (typeof e.endMs   !== 'number') { e.endMs   = toMs(e.end); }
      }
      return evts;
    }

    function setPersona(id) {
      currentPersona = PERSONAS.find(p => p.id === id) || PERSONAS[0];
      localStorage.setItem(LS_KEY_PERSONA, currentPersona.id);
      document.querySelectorAll('#personaGroup button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.id === currentPersona.id);
      });
      calendar?.refetchEvents();
      renderStatusPanel();
    }
    function setServer(id) {
      currentServerId = id;
      localStorage.setItem(LS_KEY_SERVER, id || '');
      document.querySelectorAll('.server-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.id === id);
      });
      calendar?.refetchEvents();
    }

    const overlapMs = (aStartMs, aEndMs, bStartMs, bEndMs)=> (aStartMs < bEndMs) && (aEndMs > bStartMs);

    function fmt(dt) {
      const d = new Date(dt);
      const mm = (d.getMonth()+1).toString().padStart(2,'0');
      const dd = d.getDate().toString().padStart(2,'0');
      const hh = d.getHours().toString().padStart(2,'0');
      const mi = d.getMinutes().toString().padStart(2,'0');
      return `${mm}/${dd} ${hh}:${mi}`;
    }
    const fmtRange = (s, e)=> `${fmt(s)}~${fmt(e)}`;
    function toLocalInputValue(d){
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }
    function fromLocalInputValue(v){
      if(!v) return null;
      const [date, time='00:00'] = v.split('T');
      const [y,m,d] = date.split('-').map(Number);
      const [hh,mm] = time.split(':').map(Number);
      return new Date(y, (m||1)-1, d||1, hh||0, mm||0, 0, 0);
    }

    function buildPersonaButtons() {
      const group = document.getElementById('personaGroup');
      PERSONAS.forEach(p => {
        const btn = group.querySelector(`button[data-id="${p.id}"]`);
        if (btn) {
          btn.style.borderRight = '1px solid rgba(0,0,0,0.0)';
          btn.addEventListener('click', () => setPersona(p.id));
        }
      });
      const saved = localStorage.getItem(LS_KEY_PERSONA);
      setPersona(saved && PERSONAS.some(p=>p.id===saved) ? saved : '김민준');
    }

    function buildServerList() {
      const wrap = document.getElementById('serverList');
      wrap.innerHTML = '';
      SERVERS.forEach(s => {
        const row = document.createElement('div');
        row.className = 'server-row';

        const selBtn = document.createElement('button');
        selBtn.className = 'btn server-btn';
        selBtn.dataset.id = s.id;
        selBtn.innerHTML = `<span>${s.name}</span><span class="muted" style="font-size:12px;">선택</span>`;
        selBtn.addEventListener('click', () => setServer(s.id));

        const meta = document.createElement('div');
        meta.className = 'server-meta';
        meta.innerHTML = `<span class="chip">GPU: ${s.gpuType}</span><span class="chip">${s.gpuCount}개</span>`;

        row.appendChild(selBtn);
        row.appendChild(meta);
        wrap.appendChild(row);
      });

      const saved = localStorage.getItem(LS_KEY_SERVER);
      const current = (saved && SERVERS.some(s=>s.id===saved)) ? saved : (SERVERS[0]?.id || null);
      setServer(current);
    }

    function mapToFcEvent(r) {
      const owner = PERSONAS.find(p => p.id === r.ownerId) || { name: r.ownerId, color: '#1f2937' };
      const server = getServerById(r.serverId);
      const gpuTxt = r.gpuUsed ? ` · ${r.gpuUsed}GPU` : '';

      const s = toDateSafe(r.start);
      const e = toDateSafe(r.end);

      return {
        id: r.id,
        title: r.title || '',
        start: s,
        end: e,
        backgroundColor: owner.color,
        borderColor: owner.color,
        textColor: '#ffffff',
        extendedProps: {
          ownerId: r.ownerId,
          ownerName: owner.name,
          serverId: r.serverId,
          serverName: (server?.name || r.serverId) + gpuTxt,
          gpuUsed: r.gpuUsed ?? 1,
          startMs: s.getTime(),
          endMs: e.getTime()
        }
      };
    }

    function renderEventContent(arg) {
      const { ownerName, serverName } = arg.event.extendedProps || {};
      const title = arg.event.title ? ` — ${arg.event.title}` : '';

      // 종일 스타일(00:00 ~ 다음날 00:00 배타)로 저장된 경우 라벨을 00:00~23:59로 보정
      const isAllDayLike = looksAllDaySpan(arg.event.start, arg.event.end);
      const endForLabel = isAllDayLike
        ? new Date(arg.event.end.getTime() - 60*1000) // 1분 빼서 23:59
        : arg.event.end;

      const range = `(${fmtRange(arg.event.start, endForLabel)})`;
      const el = document.createElement('div');
      el.className = 'fc-resv';
      el.style.color = '#ffffff';
      el.innerHTML = `<div class="line1">[${serverName}]${title}</div><div class="line2">${ownerName || ''} ${range}</div>`;
      return { domNodes: [el] };
    }

    async function renderStatusPanel() {
      const panel = document.getElementById('statusPanel');
      const nowMs = Date.now();
      const events = await loadEvents();
      panel.innerHTML = '';
      SERVERS.forEach(s => {
        const serverEventsNow = events.filter(e =>
          sameId(e.serverId, s.id) &&
          toMs(e.start) <= nowMs && nowMs < toMs(e.end)
        );
        const used = serverEventsNow.reduce((sum,e)=> sum + (Number(e.gpuUsed??1)||1), 0);
        const free = Math.max(0, s.gpuCount - used);

        const card = document.createElement('div');
        card.className = 'status-card';
        card.innerHTML = `
          <div class="status-name">${s.name}</div>
          <div class="gpu-badge">GPU: <span class="chip">${s.gpuType}</span> <span class="chip">총 ${s.gpuCount}개</span></div>
          <div class="bar"><span style="width:${Math.min(100, Math.max(0, (used/s.gpuCount)*100))}%;"></span></div>
          <div class="status-subgrid">
            <div><strong>${free}</strong>/<strong>${s.gpuCount}</strong> GPUs available</div>
            ${serverEventsNow.length===0 ? `<div class="status-free">현재 모두 사용 가능</div>` : serverEventsNow.map(e=>{
              const owner = PERSONAS.find(p=>p.id===e.ownerId)?.name || e.ownerId;
              return `<div class="chip">${owner} · ${e.gpuUsed??1}GPU · until ${fmt(e.end)}</div>`;
            }).join('')}
          </div>
        `;
        panel.appendChild(card);
      });
    }

    const createModal = {
      el: null, saveBtn: null, cancelBtn: null,
      titleEl: null, gpuEl: null, availEl: null, descEl: null, errEl: null,
      startEl: null, endEl: null,
      ctx: null,

      async open(ctx){
        this.ctx = ctx; // ctx.wholeDay: 월간뷰에서 만든 예약인지 여부(내부용)
        if(!this.el){
          this.el        = document.getElementById('createModal');
          this.saveBtn   = document.getElementById('cmSave');
          this.cancelBtn = document.getElementById('cmCancel');
          this.titleEl   = document.getElementById('cmTitle');
          this.gpuEl     = document.getElementById('cmGpu');
          this.availEl   = document.getElementById('cmAvail');
          this.descEl    = document.getElementById('cmServer');
          this.errEl     = document.getElementById('cmError');
          this.startEl   = document.getElementById('cmStart');
          this.endEl     = document.getElementById('cmEnd');

          this.cancelBtn.addEventListener('click', ()=> this.close());
          this.el.addEventListener('click', (e)=>{ if(e.target===this.el) this.close(); });
          this.saveBtn.addEventListener('click', ()=> this.save());

          const onChange = ()=> this.recalc();
          this.startEl.addEventListener('input', onChange);
          this.endEl.addEventListener('input', onChange);
          this.gpuEl.addEventListener('input', onChange);
        }

        this.startEl.value = toLocalInputValue(ctx.start);
        this.endEl.value   = toLocalInputValue(ctx.end);
        this.titleEl.value = '';
        this.gpuEl.value   = '1';
        this.errEl.textContent = '';
        this.el.style.display = 'grid';

        await this.recalc();
        setTimeout(()=> this.titleEl.focus(), 0);
      },

      async recalc(){
        if(!this.ctx) return;
        const start = fromLocalInputValue(this.startEl.value);
        const end   = fromLocalInputValue(this.endEl.value);

        if(!(start && end) || !(start < end)){
          this.errEl.textContent = '종료 시각은 시작 시각보다 늦어야 합니다.';
          this.availEl.textContent = '';
          this.saveBtn.disabled = true;
          return;
        }

        // 저장될 실제 시간대 기준(월간뷰: 익일 00:00 배타)
        const calcStart = this.ctx.wholeDay ? startOfDay(start) : start;
        const calcEnd   = this.ctx.wholeDay ? startOfDay(addDays(end,1)) : end;

        const events = await loadEvents();
        const usedInRange = events.reduce((sum,e)=>{
          if(!sameId(e.serverId, this.ctx.server.id)) return sum;
          if(!overlapMs(calcStart.getTime(), calcEnd.getTime(), toMs(e.start), toMs(e.end))) return sum;
          return sum + (Number(e.gpuUsed??1)||1);
        },0);

        const cap = Number(this.ctx.server.gpuCount||0);
        const available = Math.max(0, cap - usedInRange);

        this.gpuEl.min = '1';
        this.gpuEl.max = String(Math.max(available,1));
        const cur = Math.max(1, Math.min(Number(this.gpuEl.value||'1'), Math.max(available,1)));
        this.gpuEl.value = String(cur);

        // 라벨은 입력값 그대로(00:00~23:59)
        this.descEl.textContent = `서버: ${this.ctx.server.name} (${this.ctx.server.gpuType}, 총 ${cap}GPU) · 기간: ${fmtRange(start, end)}`;
        this.availEl.textContent = `이 시간대 사용 가능: ${available} / ${cap} GPU`;
        this.errEl.textContent = available>0 ? '' : '해당 시간대에 사용 가능한 GPU가 없습니다.';
        this.saveBtn.disabled = available<=0;
      },

      close(){
        this.el.style.display = 'none';
        this.errEl.textContent = '';
        this.titleEl.value = '';
        this.gpuEl.value = '1';
        this.ctx = null;
      },

      async save(){
        if(!this.ctx) return;
        const title = this.titleEl.value.trim();
        const gpuUsed = parseInt(this.gpuEl.value || '1', 10);
        const startIn = fromLocalInputValue(this.startEl.value) || this.ctx.start;
        const endIn   = fromLocalInputValue(this.endEl.value)   || this.ctx.end;
        if(!isFinite(gpuUsed) || gpuUsed<1){ this.errEl.textContent='GPU 개수는 1 이상이어야 합니다.'; return; }
        if(!(startIn < endIn)){ this.errEl.textContent='종료 시각은 시작 시각보다 늦어야 합니다.'; return; }

        // 월간뷰에서 만든 경우: DB에는 배타 종료(마지막날 다음날 00:00)로 저장
        let start = startIn;
        let end   = endIn;
        if (this.ctx.wholeDay) {
          start = startOfDay(startIn);            // 00:00
          end   = startOfDay(addDays(endIn,1));   // 다음날 00:00 (배타)
        }

        const candidate = {
          serverId: this.ctx.server.id,
          startMs: start.getTime(),
          endMs: end.getTime(),
          gpuUsed
        };
        if(! (await validateCapacity(candidate)) ) {
          this.errEl.textContent = 'GPU 용량을 초과하여 예약할 수 없어요.'; return;
        }

        const newRowData = {
          owner_id: currentPersona.id,
          title: title || null,
          server_id: candidate.serverId,
          start_time: start.toISOString(),  // UTC 저장
          end_time: end.toISOString(),      // UTC 저장(배타)
          gpu_used: gpuUsed
        };

        try{
          const { error } = await supabaseClient.from('reservations').insert(newRowData);
          if (error) throw error;
        }catch(err){
          this.errEl.textContent = '예약 저장에 실패했습니다: ' + (err?.message || err);
          return;
        }

        calendar.refetchEvents();
        renderStatusPanel();
        this.close();
      }
    };

    // ▼▼ NEW: Edit modal (우클릭 → 수정)
    const editModal = {
      el: null, saveBtn: null, cancelBtn: null,
      titleEl: null, gpuEl: null, availEl: null, descEl: null, errEl: null,
      startEl: null, endEl: null,
      ctx: null, // { event, server }

      async open(ctx){
        this.ctx = ctx;
        if(!this.el){
          this.el        = document.getElementById('editModal');
          this.saveBtn   = document.getElementById('emSave');
          this.cancelBtn = document.getElementById('emCancel');
          this.titleEl   = document.getElementById('emTitle');
          this.gpuEl     = document.getElementById('emGpu');
          this.availEl   = document.getElementById('emAvail');
          this.descEl    = document.getElementById('emServer');
          this.errEl     = document.getElementById('emError');
          this.startEl   = document.getElementById('emStart');
          this.endEl     = document.getElementById('emEnd');

          this.cancelBtn.addEventListener('click', ()=> this.close());
          this.el.addEventListener('click', (e)=>{ if(e.target===this.el) this.close(); });
          this.saveBtn.addEventListener('click', ()=> this.save());

          const onChange = ()=> this.recalc();
          this.startEl.addEventListener('input', onChange);
          this.endEl.addEventListener('input', onChange);
          this.gpuEl.addEventListener('input', onChange);
        }

        const ev = ctx.event;
        this.titleEl.value = ev.title || '';
        this.startEl.value = toLocalInputValue(ev.start);
        this.endEl.value   = toLocalInputValue(ev.end);
        this.gpuEl.value   = String(ev.extendedProps?.gpuUsed ?? 1);
        this.errEl.textContent = '';
        this.el.style.display = 'grid';

        await this.recalc();
        setTimeout(()=> this.titleEl.focus(), 0);
      },

      async recalc(){
        if(!this.ctx) return;
        const start = fromLocalInputValue(this.startEl.value);
        const end   = fromLocalInputValue(this.endEl.value);
        const currentUsed = Number(this.gpuEl.value || '1');

        if(!(start && end) || !(start < end)){
          this.errEl.textContent = '종료 시각은 시작 시각보다 늦어야 합니다.';
          this.availEl.textContent = '';
          this.saveBtn.disabled = true;
          return;
        }

        const events = await loadEvents();
        const cap = Number(this.ctx.server.gpuCount||0);
        const usedInRange = events.reduce((sum,e)=>{
          if(e.id===this.ctx.event.id) return sum; // 본인 예약 제외
          if(!sameId(e.serverId, this.ctx.server.id)) return sum;
          if(!overlapMs(start.getTime(), end.getTime(), toMs(e.start), toMs(e.end))) return sum;
          return sum + (Number(e.gpuUsed??1)||1);
        },0);
        const available = Math.max(0, cap - usedInRange);
        const allowedMax = Math.max(1, Math.min(cap, available + (this.ctx.event.extendedProps?.gpuUsed ?? 1)));

        this.gpuEl.min = '1';
        this.gpuEl.max = String(allowedMax);
        const clamped = Math.max(1, Math.min(currentUsed, allowedMax));
        if (clamped !== currentUsed) this.gpuEl.value = String(clamped);

        this.descEl.textContent = `서버: ${this.ctx.server.name} (${this.ctx.server.gpuType}, 총 ${cap}GPU) · 기간: ${fmtRange(start, end)}`;
        this.availEl.textContent = `이 시간대 사용 가능: ${available} / ${cap} GPU (현재 예약 포함 최대 ${allowedMax}GPU)`;
        this.errEl.textContent = allowedMax>0 ? '' : '해당 시간대에 사용 가능한 GPU가 없습니다.';
        this.saveBtn.disabled = allowedMax<=0;
      },

      close(){
        this.el.style.display = 'none';
        this.errEl.textContent = '';
        this.ctx = null;
      },

      async save(){
        if(!this.ctx) return;
        const title = this.titleEl.value.trim();
        const gpuUsed = parseInt(this.gpuEl.value || '1', 10);
        const start = fromLocalInputValue(this.startEl.value) || this.ctx.event.start;
        const end   = fromLocalInputValue(this.endEl.value)   || this.ctx.event.end;
        if(!isFinite(gpuUsed) || gpuUsed<1){ this.errEl.textContent='GPU 개수는 1 이상이어야 합니다.'; return; }
        if(!(start < end)){ this.errEl.textContent='종료 시각은 시작 시각보다 늦어야 합니다.'; return; }

        const candidate = {
          serverId: this.ctx.server.id,
          startMs: start.getTime(),
          endMs: end.getTime(),
          gpuUsed
        };
        if(! (await validateCapacity(candidate, this.ctx.event.id)) ) {
          this.errEl.textContent = 'GPU 용량을 초과하여 수정할 수 없어요.'; return;
        }

        try{
          const { error } = await supabaseClient
            .from('reservations')
            .update({
              title: title || null,
              start_time: start.toISOString(),
              end_time: end.toISOString(),
              gpu_used: gpuUsed
            })
            .eq('id', this.ctx.event.id);
          if (error) throw error;
        }catch(err){
          this.errEl.textContent = '업데이트에 실패했습니다: ' + (err?.message || err);
          return;
        }

        calendar.refetchEvents();
        renderStatusPanel();
        this.close();
      }
    };
    // ▲▲ NEW

    async function validateCapacity(candidate, exceptId){
      const server = getServerById(candidate.serverId); if(!server) return false;
      const cap = Number(server.gpuCount||0);
      const cStart = candidate.startMs ?? toMs(candidate.start);
      const cEnd   = candidate.endMs   ?? toMs(candidate.end);

      const events = await loadEvents();
      const used = events.reduce((sum,e)=>{
        if(e.id===exceptId) return sum;
        if(!sameId(e.serverId, candidate.serverId)) return sum;
        if(!overlapMs(cStart, cEnd, toMs(e.start), toMs(e.end))) return sum;
        const u = Number(e.gpuUsed ?? 1);
        return sum + (isFinite(u) && u>0 ? u : 1);
      }, 0);
      const need = Number(candidate.gpuUsed ?? 1);
      return (used + need) <= cap;
    }

    // ▼▼ NEW: permissions + delete helper
    function canModifyEvent(ev){
      const ownerId = ev.extendedProps?.ownerId;
      return currentPersona && (isAdmin() || ownerId === currentPersona.id);
    }
    async function deleteEvent(ev){
      if (!canModifyEvent(ev)) { alert('내 예약만 삭제할 수 있어요.'); return; }
      const serverName = ev.extendedProps?.serverName || ev.extendedProps?.serverId || '';
      if (!confirm(`[${serverName}] 예약을 삭제할까요?`)) return;
      const { error } = await supabaseClient
        .from('reservations')
        .delete()
        .eq('id', ev.id);
      if (error) { alert('삭제에 실패했습니다: ' + error.message); return; }
      calendar.refetchEvents();
      renderStatusPanel();
    }
    // ▲▲ NEW

    // ▼▼ NEW: lightweight context menu controller
    const ctxMenu = (function(){
      const el = document.getElementById('ctxMenu');
      let targetEvent = null;
      function hide(){ el.style.display = 'none'; el.setAttribute('aria-hidden','true'); targetEvent=null; }
      function show(x,y, ev){
        targetEvent = ev;
        el.innerHTML = `<button data-act="edit">수정</button><button data-act="delete">삭제</button>`;
        el.style.display = 'block';
        el.setAttribute('aria-hidden','false');
        // position within viewport
        const vw = window.innerWidth, vh = window.innerHeight;
        const rectW = 180; const rectH = 100;
        const left = Math.min(x, vw - rectW - 8);
        const top  = Math.min(y, vh - rectH - 8);
        el.style.left = left + 'px';
        el.style.top  = top + 'px';
      }
      el.addEventListener('click', (e)=>{
        const act = e.target?.dataset?.act;
        if(!act) return;
        const ev = targetEvent; hide();
        if(!ev) return;
        if (act==='edit') {
          const server = getServerById(ev.extendedProps?.serverId);
          if (!canModifyEvent(ev)) { alert('본인 예약만 수정할 수 있어요.'); return; }
          editModal.open({ event: ev, server });
        } else if (act==='delete') {
          deleteEvent(ev);
        }
      });
      document.addEventListener('click', (e)=>{ if(el.style.display==='block' && !el.contains(e.target)) hide(); });
      document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hide(); });
      window.addEventListener('blur', hide);
      window.addEventListener('scroll', ()=>{ if(el.style.display==='block') hide(); }, true);
      return { show, hide };
    })();
    // ▲▲ NEW

    async function initCalendar() {
      const calendarEl = document.getElementById('calendar');
      calendar = new FullCalendar.Calendar(calendarEl, {
        locale: 'ko',
        timeZone: 'local',
        initialView: 'dayGridMonth',
        height: 'auto',
        selectable: true,
        selectMirror: true,
        editable: true,
        dayMaxEvents: true,
        nowIndicator: true,
        headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,timeGridWeek,timeGridDay' },
        eventTimeFormat: { hour: '2-digit', minute: '2-digit', hour12: false },
        eventContent: renderEventContent,

        events: async (fetchInfo, successCallback, failureCallback) => {
          try {
            const data = await loadEvents();
            successCallback(data.map(mapToFcEvent));
          } catch (error) {
            failureCallback(error);
          }
        },

        dateClick: (info) => {
          if (!currentServerId) { alert('좌측에서 서버를 먼저 선택하세요.'); return; }
          if (!currentPersona) { alert('상단에서 사용자를 선택하세요.'); return; }
          const server = getServerById(currentServerId);
          if(!server){ alert('서버 정보를 찾을 수 없습니다.'); return; }

          const wholeDay = !!(info.view?.type?.startsWith('dayGrid'));
          let selStart, selEnd;

          if (wholeDay) {
            selStart = startOfDay(info.date);      // 당일 00:00
            selEnd   = endOfDayForInput(info.date);// 당일 23:59 (입력 기본값)
          } else {
            selStart = info.date;
            selEnd   = new Date(info.date.getTime() + 60*60*1000);
          }
          createModal.open({ server, start: selStart, end: selEnd, wholeDay });
        },

        select: (info) => {
          if (!currentServerId) { alert('좌측에서 서버를 먼저 선택하세요.'); calendar.unselect(); return; }
          if (!currentPersona) { alert('상단에서 사용자를 선택하세요.'); calendar.unselect(); return; }
          const server = getServerById(currentServerId);
          if(!server){ alert('서버 정보를 찾을 수 없습니다.'); calendar.unselect(); return; }

          const wholeDay = !!(info.view?.type?.startsWith('dayGrid'));
          let selStart, selEnd;

          if (wholeDay) {
            selStart = startOfDay(info.start);           // 시작일 00:00
            const inclusiveEnd = new Date(info.end);
            inclusiveEnd.setDate(inclusiveEnd.getDate() - 1);
            selEnd   = endOfDayForInput(inclusiveEnd);   // 마지막날 23:59
          } else {
            selStart = info.start;
            selEnd   = info.end;
          }

          createModal.open({ server, start: selStart, end: selEnd, wholeDay });
          calendar.unselect();
        },

        eventDrop: async (info) => {
          const ownerId = info.event.extendedProps?.ownerId;
          if (!currentPersona || (!isAdmin() && ownerId !== currentPersona.id)) { alert('본인 예약만 이동할 수 있어요.'); info.revert(); return; }

          const oldStartMs = info.event.extendedProps?.startMs;
          const oldEndMs   = info.event.extendedProps?.endMs;
          let newStartMs, newEndMs;

          if (info.view?.type?.startsWith('dayGrid')) {
            const oldStart = new Date(oldStartMs);
            const newStart = info.event.start;
            const dayDelta = Math.round((ymdUTC(newStart) - ymdUTC(oldStart)) / MS_PER_DAY);
            newStartMs = oldStartMs + dayDelta * MS_PER_DAY;
            newEndMs   = oldEndMs   + dayDelta * MS_PER_DAY;
          } else {
            newStartMs = info.event.start.getTime();
            newEndMs   = info.event.end.getTime();
          }

          const updated = {
            start: new Date(newStartMs).toISOString(),
            end:   new Date(newEndMs).toISOString(),
            startMs: newStartMs,
            endMs:   newEndMs,
            gpuUsed: info.event.extendedProps?.gpuUsed ?? 1
          };

          if (! (await validateCapacity({ serverId: info.event.extendedProps.serverId, ...updated }, info.event.id)) ) {
            alert('GPU 용량을 초과하여 이동할 수 없어요.');
            info.revert();
            return;
          }

          const { error } = await supabaseClient
            .from('reservations')
            .update({ start_time: updated.start, end_time: updated.end })
            .eq('id', info.event.id);

          if (error) {
            alert('업데이트에 실패했습니다: ' + error.message);
            info.revert();
            return;
          }
          calendar.refetchEvents();
          renderStatusPanel();
        },

        eventResize: async (info) => {
          const ownerId = info.event.extendedProps?.ownerId;
          if (!currentPersona || (!isAdmin() && ownerId !== currentPersona.id)) { alert('본인 예약만 수정할 수 있어요.'); info.revert(); return; }

          let newStartMs = info.event.start.getTime();
          let newEndMs   = info.event.end.getTime();

          const updated = {
            start: new Date(newStartMs).toISOString(),
            end:   new Date(newEndMs).toISOString(),
            startMs: newStartMs,
            endMs:   newEndMs,
            gpuUsed: info.event.extendedProps?.gpuUsed ?? 1
          };

          if (! (await validateCapacity({ serverId: info.event.extendedProps.serverId, ...updated }, info.event.id)) ) {
            alert('GPU 용량을 초과하여 수정할 수 없어요.');
            info.revert();
            return;
          }

          const { error } = await supabaseClient
            .from('reservations')
            .update({ start_time: updated.start, end_time: updated.end })
            .eq('id', info.event.id);

          if (error) {
            alert('업데이트에 실패했습니다: ' + error.message);
            info.revert();
            return;
          }
          calendar.refetchEvents();
          renderStatusPanel();
        },

        // ▼▼ NEW: left-click keeps old behavior (delete), right-click shows menu
        eventClick: async (info) => {
          const ownerId = info.event.extendedProps?.ownerId;
          const canDelete = currentPersona && (isAdmin() || ownerId === currentPersona.id);
          if (!canDelete) { alert('내 예약만 삭제할 수 있어요.'); return; }
          const serverName = info.event.extendedProps?.serverName;
          if (confirm(`[${serverName}] 예약을 삭제할까요?`)) {
            const { error } = await supabaseClient
              .from('reservations')
              .delete()
              .eq('id', info.event.id);

            if (error) {
              alert('삭제에 실패했습니다: ' + error.message);
              return;
            }
            calendar.refetchEvents();
            renderStatusPanel();
          }
        },
        eventDidMount: (arg) => {
          arg.el.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!canModifyEvent(arg.event)) { alert('본인 예약만 수정/삭제할 수 있어요.'); return; }
            ctxMenu.show(e.clientX, e.clientY, arg.event);
          });
        }
        // ▲▲ NEW
      });
      calendar.render();
    }

    buildPersonaButtons();
    buildServerList();
    initCalendar();
    renderStatusPanel();
    setInterval(renderStatusPanel, 15000);
  })();
  </script>
</body>
</html>